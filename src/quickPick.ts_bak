import {
  DocumentSymbol, window, Uri, TextDocument, commands, ThemeIcon, QuickInputButton,
  QuickPickItemButtonEvent, Position, Range, Selection, TextEditorRevealType,
  ExtensionContext
} from 'vscode';

import * as Globals from './myGlobals';
import * as arrowFunctions from './arrowFunctions';
import {filterDepthMap, unfilteredDepthMap} from './depthMap';
import {traverseSymbols} from './qpTraverse';
import {BoundedCache} from './mapCache';

import type {SymMap, SymbolPickItem, SymbolMap, NodePickItems} from './types';
import {mapKindToNameAndIconPath} from './symbolKindMap';
import {collectSymbolItemsFromSource} from './nodeList';
import {filterDocNodes} from './nodeFilter';
import {showQuickPickMessage} from './messages';
import {isMap} from 'util/types';


// local "globals"
let kbSymbolsSaved: (keyof SymMap)[];
let filterState: string = "filtered";

let docSymbols: DocumentSymbol[] = [];
let arrowFunctionSymbols: DocumentSymbol[] = [];

let symbolDepthMap: SymbolMap = new Map();
let filteredDepthMap: SymbolMap = new Map();
let allDepthMap: SymbolMap = new Map();

let allDocNodes: NodePickItems = [];
let filteredDocNodes: NodePickItems = [];

const _Globals = Globals.default;

type QuickPickCache = {
  refreshSymbols: boolean;
  symbols: NodePickItems;
};

// Create a bounded cache of Map <Uri → QuickPickCache> with max size 3
const cache = new BoundedCache<Uri, QuickPickCache>(3);




// Get the Nodes using tsc, and return filtered nodes
export async function getNodes(kbSymbols: (keyof SymMap)[], getNewNodes: boolean, document: TextDocument): Promise<NodePickItems | undefined> {

  kbSymbolsSaved = kbSymbols;

  if (getNewNodes) {
    allDocNodes = await collectSymbolItemsFromSource(document);

    symbolDepthMap.clear();
    filteredDepthMap.clear();
    allDepthMap.clear();

    filteredDocNodes = [];
    docSymbols = [];
  }

  if (allDocNodes.length) {
    // if no kbSymbols, don't bother to filter // can that ever happen - defaults to all?
    filteredDocNodes = await filterDocNodes(kbSymbols, allDocNodes);
  }
  else {
    showQuickPickMessage("QuickPick: Found no document symbols in this editor.");
    return undefined;
  }

  if (!filteredDocNodes.length) {
    showQuickPickMessage("QuickPick: There are no document symbols remaining AFTER applying your 'symbols' from the keybinding.");
    return undefined;
  }
  return filteredDocNodes;
}

/**
 * 1. Get doc symbols from vscode.executeDocumentSymbolProvider
 * 2. Build an array of symbols for arrow functions (else identified as variables)
 * 3. Build a depth map of all symbols
 * 4. Filter the depth map for keybinding "symbols"
 */
export async function getSymbols(kbSymbols: (keyof SymMap)[], getNewSymbols: boolean, document: TextDocument,): Promise<SymbolMap | undefined> {

  kbSymbolsSaved = kbSymbols;

  // current document was  or  current document is not the one for which the symbols were retrieved
  if (getNewSymbols) {
    docSymbols = await commands.executeCommand('vscode.executeDocumentSymbolProvider', document.uri);

    symbolDepthMap.clear();
    filteredDepthMap.clear();
    allDepthMap.clear();

    allDocNodes = [];
    filteredDocNodes = [];

    if (_Globals.isJSTS) {
      arrowFunctionSymbols = await arrowFunctions.makeSymbolsFromFunctionExpressions(document) || [];
    }
    else arrowFunctionSymbols = [];

    if (docSymbols) {          // in if (getNewSymbols)
      symbolDepthMap.clear();
      symbolDepthMap = traverseSymbols(docSymbols, symbolDepthMap, document);
    }
  }

  // this is the filtering step and also merges the arrowFunctions
  if (symbolDepthMap.size) {
    filteredDepthMap = await filterDepthMap(arrowFunctionSymbols, symbolDepthMap, kbSymbolsSaved);

    if (!filteredDepthMap.size) {
      showQuickPickMessage("There are no document symbols remaining AFTER applying your 'symbols' from the keybinding.");
      return undefined;
    }
    return filteredDepthMap;
  }

  else {
    showQuickPickMessage("There are no document symbols remaining AFTER applying your 'symbols' from the keybinding.");
    ("Found no document symbols in this editor.");
    return undefined;
  }

};


/**
 * Show a QuickPick of the document symbols in options 'symbols'
 */
export async function render(items: NodePickItems | SymbolMap, context: ExtensionContext) {

  const doc = window.activeTextEditor?.document;
  if (!doc) return;

  filterState = "filtered";

  const filterButton: QuickInputButton = {
    iconPath: new ThemeIcon('filter'), // s/b in Stable early December, 2025

    // iconPath: {
    //   dark: Uri.joinPath(context.extensionUri, 'resources/dark/filter.svg'),
    //   light: Uri.joinPath(context.extensionUri, 'resources/light/filter.svg')
    // },
    tooltip: 'Toggle Filter'
  } as const;

  // const refreshButton = 
  //   iconPath: new ThemeIcon('refresh'),
  //   tooltip: 'Refresh list'
  // };

  const selectButton: QuickInputButton = {
    iconPath: new ThemeIcon('selection'),
    tooltip: 'Select Symbol'
  } as const;

  let qpItems: SymbolPickItem[] = [];

  if (isMap(items)) {  // for SymbolMap, non-tsc

    items.forEach((depth, symbol) => {
      let label = `${symbol.name}: ${symbol.detail}`;
      if (depth) label = ('└─  ' + label).padStart(label.length + (depth * 10), ' ');

      qpItems.push({
        // do a reverse mapping from symbol.kind -> "class", "function", etc.
        // description: ` (${mapKindToNameAndIconPath.get(symbol.kind)?.name})`, // var => arrow fn

        label: label + ` --- (${mapKindToNameAndIconPath.get(symbol.kind)?.name})`,
        range: symbol.range,
        selectionRange: symbol.selectionRange,
        buttons: [selectButton],
      });
    });
  }

  else if (Array.isArray(items)) {  // for NodePickItems, using tsc

    items.forEach(item => {
      let label = item.label;
      if (item.depth > 0) label = ('└─  ' + label).padStart(item.label!.length + (item.depth * 10), ' ');

      qpItems.push({
        label: `${label}   ---  (${item.detail})`,
        range: item.range,
        selectionRange: item.selectionRange,
        buttons: [selectButton],
      });
    });
  }

  const qp = window.createQuickPick<SymbolPickItem>();
  qp.ignoreFocusOut = true;
  qp.items = qpItems;
  qp.title = 'Select Symbols';
  (qp as any).sortByLabel = false;  // stop alphabetical resorting, especially in onDidChangeValue() below

  qp.buttons = [filterButton];
  // qp.buttons = [filterButton, refreshButton];


  // this is for "filtering/searching" in the QuickPick
  // fuzzysort performs fuzzy searching
  // qp.onDidChangeValue(newValue => {

  //   if (!newValue) {       // for when QuickPick input is empty
  //     qp.items = qpItems;
  //     return;
  //   }

  //   // const results = fuzzysort.go(newValue, qpItems, {key: "label"});
  //   const results = fuzzysort.go(newValue, qpItems, {key: "label"});
  //   qp.items = results.map((result: any) => result.obj)
  //     .sort(sortQPItems);
  // });


  qp.onDidTriggerItemButton((event: QuickPickItemButtonEvent<SymbolPickItem>) => {

    const editor = window.activeTextEditor;
    const document = editor?.document;
    if (!document) return;

    const target = event.item;

    let extendedRange;
    const lastLineLength = document.lineAt(target.range.end).text.length;

    extendedRange = target.range.with({
      start: new Position(target.range.start.line, 0),
      end: new Position(target.range.end.line, lastLineLength)
    });

    editor.selections = [new Selection(extendedRange.end, extendedRange.start)];
    editor.revealRange(new Range(editor.selections[0].anchor, editor.selections[0].active), TextEditorRevealType.Default);  // Default = 0, as little scrolling as necessary

    qp.hide();
  });


  // select an item
  qp.onDidChangeSelection((selectedItems: readonly SymbolPickItem[]) => {
    const editor = window.activeTextEditor;
    const document = editor?.document;
    if (!document) return;

    const target: Range = selectedItems[0].selectionRange;
    editor.selections = [new Selection(target.start, target.start)];
    editor.revealRange(new Range(editor.selections[0].active, editor.selections[0].active), TextEditorRevealType.InCenter);  // Default = 0, as little scrolling as necessary

    qp.hide();
  });


  // filterButton
  // make the filtered version first and save it, then, if called, make the All version and save it
  qp.onDidTriggerButton(async button => {

    const document = window.activeTextEditor?.document;
    if (!document) return;

    if (button === filterButton) {
      if (symbolDepthMap.size) {
        if (filterState === "filtered") {
          if (!allDepthMap.size)
            allDepthMap = await unfilteredDepthMap(arrowFunctionSymbols, symbolDepthMap);
          if (allDepthMap.size) {
            // await module.exports.render(isJSTS, allDepthMap);
            await render(allDepthMap, context);
            filterState = "not filtered";
          }
        }
        else {
          if (!filteredDepthMap.size)
            filteredDepthMap = await filterDepthMap(arrowFunctionSymbols, symbolDepthMap, kbSymbolsSaved);
          if (filteredDepthMap.size) {
            await render(filteredDepthMap, context);
            filterState = "filtered";
          }
        }
      }
      else if (allDocNodes.length) {
        if (filterState === "filtered") {
          if (!allDocNodes.length)
            allDocNodes = await collectSymbolItemsFromSource(document);
          if (allDocNodes.length) {
            await render(allDocNodes, context);
            filterState = "not filtered";
          }
        }
        else {
          if (!filteredDocNodes.length)
            filteredDocNodes = await filterDocNodes(kbSymbolsSaved, allDocNodes);
          if (filteredDocNodes.length) {
            await render(filteredDocNodes, context);
            filterState = "filtered";
          }
        }
      }
    }
  });

  // click the OK button WITH a selection
  // if !canSelectMany this fires with each selection
  // qp.onDidAccept(() => {
  // 	const selected = qp.selectedItems[0];
  // 	vscode.window.showInformationMessage(`You selected: ${selected.label}`);
  // 	qp.hide();
  // });

  qp.onDidHide(() => qp.dispose());

  qp.show();
};